== Collections and Databases

A key value proposition of web sites is that they provide global access to persistent information. We typically store the persistent information in databases and files on a file system. Databases store the data as tables (or sometimes more complex structures, but for now, let's stick with tables).

A table is a set of rows, where each row has the same entries (the entry is called a column in the database). In OO design, you typically define an object that holds as its properties the entries within a row; so a table can be viewed as holding a collection of rows, or objects.

C# uses this model when it interacts with databases -- a query against a table returns a collection of objects; each property in a returned object maps to a column in the table or query.

=== Collections

C# has one built-in collection, the array. Arrays are fine, but consider what happens when you need to remove the second item in an array: if it's an array of objects, you can put a `null` there, but if it's a primitive, it has to have a value. If you wanted to "fill" the hole but maintain order, you would have to copy down all of the entries above, and then track that the array has one more entry empty at the end.  Collections are much richer: they do all of that management of entries for you, so you can add and remove entries as you need to. They can also maintain an order, based on the collection type: some maintain a sorted order, some maintain the order items were inserted.

An interesting feature that makes all of this possible is the generic class. A generic class lets you specialize a class when you use it, providing additional types used by that class. This lets you say what your collection holds; so you can specialize your collection to contain a particular type of object, rather than any object at all. This is similar to how you give an element type for your array when you declare it; that type is the only type allowed in the array (if it is a class, then instances of the class or of any of its subclasses are allowed).

==== Collection Interfaces

Although the implementations of collections provided in C# are classes, it defines interfaces for them as well. It is wise to use the interface on your variables, and restrict use of classes to the `new` statement. This lets you replace the chosen class with another one if you need to alter its performance or sort behavior. Collections' performance differ based on the types of operations you are performing or the type of sorting that is desired, if any.

[cols="1,4"]
|====
2+|The main Collection interfaces

|ICollection | the most general interface; it mainly defines Count, ToArray, and GetEnumerator
|IDictionary | a collection of key/value pairs; values can be accessed by keys . The Keys function on an IDictionary will return an ICollection containing just the keys.
|IList | a collection that can be accessed by a numeric index (like an array)
|====

There are two more interfaces in `System.Collections` which we make heavy use of: `IEnumerator`and `IEnumerable`. A class that implements `IEnumerator` will provide an `IEnumerable`. This is important because `IEnumerable` lets you not only move through the collection item by item, but also lets you access the collection's elements using a foreach loop. We say that the foreach loop enumerates through the items in the collection.

==== Collection Classes

The popular collection classes are:

[cols="1,1,3"]
|====
3+| Popular Collection classes

| ArrayList | IList | Items are ordered in the list. This looks alot like an array, but it lets you add and remove items dynamically (resizing the array). Sort and search capabilities are provided as well.
| Hashtable | IDictionary | Keys map to values, and you use keys to access the elements. The collection is not sorted; with a good hash function (which is used to assign storage locations), your data is dispersed in memory and both access and removal are quick.
| SortedList | IList & IDictionary | this allows both key and index access into a list; its entries when indexed contain both key and value. It is sorted on the key values.
| Stack | IList | the stack is a special type of list that only allows items to be pushed on top of the stack and taken off of the top of the stack. Knowing this is the main type of access lets the implementation focus on being fast for those accesses. It is often described as "Last In, First Out".
| Queue | IList | the queue is a special type of list as well; it only allows
items to be added at one end, and taken off of the other end. It is described as "First In, First Out".
|====

When you use these, or the interfaces, you can just use them "as-is", as they are fully-fledged classes. However, when you do that, it means the collection can contain any type of object at all; the default element type in the collection is object. And, boxing and unboxing means that primitives will get boxed up and stored in your collection as well.

==== Generic Collections

If you want to ensure that your collection contains only a particular type of object, you can do so by using a generic Collection type that permits adding a special type parameter to the class. This uses <> notation rather than a method's () notation for its parameters.

|====
| List<element-type> | a type-safe ArrayList, permits any instance of element-type or its subtypes
| Dictionary<key-type,value-type> | a type-safe Hashtable, permits any instance of the key-type or its subclasses for the key, and any instance of value-type or its subclasses for the value.
|====

So, an ArrayList can hold anything: ints (boxed), Cars, Pirates, even ArrayLists. But a List<Pirate> can hold only Pirates and instance of subclasses of Pirates.

When you want to ensure your collection contains only a particular type of objects, use the generic collections.  This ability is referred to as *generic classes*, since you create a new, specialized class when you provide the type parameters to it.

C# provides a way for you to create your own generic classes as well; however that is advanced programming, not covered in this text.

==== Example using collections

[source,java]
----
@using System.Collections.Generic;

... later in the page ...

@{
  IDictionary<string,int> phoneBook; // a map from strings to integers

  phoneBook = new Dictionary<string,int>();

  phoneBook.Add("Sarah Adams",1234567);
  phoneBook.Add("Jim Jones",5551212);
  phoneBook.Add("Nancy Smith",5010001);
  phoneBook.Add("Bill Blass",1237654);

  if (phoneBook.ContainsKey("Jim Jones")) {
    <p>Jim Jone's phone number is @phoneBook["Jim Jones"]</p>
  }
  else {
    <p>No phone number for Jim Jones.</p>
  }

  /// can also add items like so:
  phoneBook["Sam Sanders"] = 5051122;
  
  // this will also update an existing item:
  phoneBook["Nancy Smith"] = 5019999;
  
  ICollection<string> names = phoneBook.Keys;

  <p>Here is your current phone list:</p>
  foreach (string name in names) {
    // the key indexes into the dictionary to retrieve the value:
    <p>@name : @phoneBook[name]</p>
  }

}
----

=== Database Access

Today there are two popular database choices: Relational or NoSQL databases. For this text, our focus is a relational database. These databases store data in tables, which have rows and columns. You can query the database, selecting which rows you want from your tables and then which columns from the rows. You do this with the language SQL.

[NOTE]
====
This text assumes familiarity with SQL, so it will not introduce it to you, but will use it and provide descriptions of that use. We use Microsoft SQL Server Compact Edition through Visual Studio and IIS Express; applications developed in this manner transfer seamlessly to Microsoft SQL Server when deployed. But to deploy onto Oracle, MySQL, or some other database, you would need to adjust the connection mechanism and possibly the SQL syntax, as each database system has its own dialect of SQL.
====

Let's assume we have a contact list in our database with the following data:

|====
| Id | Name | PhoneNumber | Email | TwitterHandle

| 1 | Sarah Adams | 123-4567 | sarah@nowhere.com | @sarahnowhere
| 2 | Jim Jones | 555-1212 | jjones@gmail.com | @jjones3254
| 3 | Nancy Smith | 501-0001 | null | @flywitheagles
| 4 | Bill Blass | 123-7654 | bblass@bblass.net | @blassisback
|====

Note that we have an Id column; this is because good database design requires having a unique identifier (called a primary key) for each row. Name may not be good enough to be unique, if we have lots of contacts. Strings are slower in comparisons than integers, so we will usually see integers used as Id values.


In order to access a database, you first need to create one; in Visual Studio, in addition to IIS Express providing a local web server, SQL Server Express provides a local database server.

==== Create a Database

To create a database for your website, you must have it open in Visual Studio. If your website has an App_Data folder with a .sdf or .mdf file in it, then it already has a database; if you choose to use that one, jump ahead to "Create a Table".

If you do not have an App_Data directory in your project, right click in the Solution Explorer window on your web site/project name and click Add; in its menu click Add ASP.NET directory; and select App_Data from the list provided. You want to use this menu and not create it in the file system so that your project knows it exists.

Once you have an App_Data directory, right-click on that and click Add; then click Add New Item. In the dialog, under Installed>Visual C#, you should see "SQL Server database" in the list of choices. Select that, and then enter a name for your database (keep the .mdf file extension intact).

Once you are done, your database should appear under App_Data.

==== Database Configuration in Web.config

Your project Web.config file needs to have a connection string for your database. Check, and if it does not, add within the <connectionStrings> section of the file the following XML:

[source,xml]
----
  ... if tag not found, add this as a child of <configuration>, 
  ... after  <system.web>
  <connectionStrings>
    <add name="DatabaseName" connectionString="Data source=(LocalDB)\MSSQLLocalDB;|DataDirectory|\DatabaseName.mdf;Initial Catalog=DatabaseName;Integrated Security=true" providerName="System.Data.SqlClient"/>
    ... the rest of the element's children, if any
  </connectionStrings>
----

Replace DatabaseName in 3 places with the name you gave your database file. If you need to make this change, you will want to check that the setting in Tools->Options->Database Tools->Data Connections says `(LocalDB)\MSSQLLocalDB`. If you need to make either of these changes, exit and restart Visual Studio to ensure the changes are used when you access the database from within Visual Studio (before you create the table).

==== Create a Table

Creating a database is an administrative task that requires actions such as those done above; however, creating a table can be done by issuing an SQL statement. It's up to you, to do it manually or programmatically. If you code it, then you can re-run that code in the future to create the table again; if you do it manually, you will need to repeat the steps each time you want the table re-created. It is not uncommon for web developers to keep special pages for their website that will issue SQL commands to check or recreate the database.

===== Manual table creation

. Click on the "Server Explorer" tab to open it (it is under View if you do not have the tab visible already).
. If it is not open, click to open the list under "Data Connections". You should see your database there, click to expand its contents if it is not showing a list within it.
. Right-click on the Tables item (first in the list, usually) and click "Add New Table".
. This puts you in the table designer, where you can either create the table using the chart, defining each column and its type, or enter the SQL in the window at the bottom of the page.
+
Enter the following SQL to create our table:

[source,sql]
----
CREATE TABLE PhoneBook( 
  Id INT NOT NULL IDENTITY PRIMARY KEY,
  Name VARCHAR(50),
  PhoneNumber INT,
  Email VARCHAR(100),
  TwitterHandle VARCHAR(20)
  )
----

Click Update in the table design window. It will then ask if you want a Script before it does the update. Typically database administration involves keeping a collection of SQL commands in scripts to re-run them at a future date to update or repair a database. This is one such script. Since we have the command here, you can skip that and just click Update Database.

The log window will show if the database was successfully updated or not.

Once the table is created, you will need to right-click and click Refresh on your database name in the Server Explorer window for it to appear.


===== Code to create the table

The following Razor Page presents us with buttons; when clicked, they return us to the page and execute the specified SQL command.

.DBAdmin.cshtml
[source,html]
----
include::source/DBAdmin.cshtml[]
----

This is an interesting Razor example since it uses several features of Razor, C#,and HTML:

* @using -- to import the namespace that SQLException lives in
* try..catch -- so we can tell the user if something went wrong with the SQL command; note that returning stack traces is not good in live sites, you would want to protect this by requiring that the page only be used by administrators (see the next chapter for security information).
* we also used a finally block; it's important to free up the database connection when you are done with it, as it is holding onto quite a few system resources. If you don't explicitly close it, eventually the garbage collector will clean it up, but it's not a good idea to rely on that happening. We use a finally because it ensures the connection is closed no matter what exception was thrown.
* We use a special string value syntax, opening it with C#'s @",so that our long SQL command string can span lines in the file.
* The form has two submit buttons with the same name and different values; this is how the POST action can tell which button was clicked -- the value of the clicked button is the value of the buttons' name in the `Request.Form` dictionary.
* Notice if a form submission is manufactured with a bad choice, no command is run -- we don't even tell the user it was an invalid choice. This was a design decision, to give back minimal information to malicious users (since only spoofed POSTs could use bad values).

=== Put Data in the Table (INSERT)

Once you have a table, you need to be able to put data into it. If your table's data is static, you can do this through the Server Explorer view of the table in Visual Studio. If you right-click on the table in the Server Explorer view, you can see its data with the "Show Table Data" menu item. This shows you the data, and if you enter additional rows, they are saved to the table.

However, it is likely you will want to update your tables from your website; either as an administrative action or to let users share data with one another. You could request data directly from the user with a form, or you could collect the data more indirectly, such as a GPS location request or to save the results of a game they played in their browser.

[WARNING]
====
When passing user data to an SQL command, do not ever just concatenate a user string to
your SQL command. If you do, you open up your system to an *SQL Injection* attack, which can wreak havoc within your database system. For a hint at how to do this, see the XKCD comic usually referred to as https://xkcd.com/327/[Little Bobby Tables] (http://creativecommons.org/licenses/by-nc/2.5/[CC-BY-NC-2.5]):

image::images/exploits_of_a_mom.png[]

We will always use safe strings, either checking values or passing them through *dynamic parameters* to prevent SQL injection attacks.
====

In order to issue an INSERT command, we have to connect to the database, and then we can issue commands to it. Database connections use the connection name assigned in the Web.config file, so we make the connection like this:

[source,java]
----
var db = Database.Open("PhoneBookDB"); 
----

Notice we are just letting C# determine the type of the variable `db`; in fact it is a Database, which is a helper class in `WebMatrix.Data`, supplied to make direct database interactions available.

``PhoneBookDB`` is the name I gave this database in the Web.config file. It is usually the database name without the .mdf file extension.

Once you have a connection, you can issue an INSERT into a table that exists in that database. If the table does not exist, you will get an SQLException.  The INSERT needs to list the columns and then list its parameters in the same order. Here is an insert into our PhoneBookDB:

[source,java]
----
    var insertQuery = "INSERT INTO Product (Name, Description, Price) " +
                "VALUES (@0, @1, @2)";
    db.Execute(insertQuery, Name, Description, Price);
----

The @0, @1, and @2 are not Razor @'s, here they are SQL @'s, marking the parameters to the SQL statement. This protects against SQL injection because the values supplied are kept separate and not simply concatenated into the SQL string. 

[CAUTION]
====
Never, ever, ever, do this instead:

----
var insertQuery = "INSERT INTO Product (Name, Description, Price) " +
                "VALUES (\""+@Name+"\",\""+Description+"\","+@Price+")";
db.Execute(insertQuery);
----

Why not? because if Name came directly from a form field, it can contain malicious content that will take over the command and turn it into whatever SQL command the malicious user wants to make your database do, such as dropping all the tables or pulling out private data.
====

When you create your INSERT statement, you need to list all of the columns that you want to supply data for. If a column is not listed, then a SQL NULL value is put into that column in the new row.

Here is a page that will insert data into our table; note that if the form has no data, it is going to put in empty strings or 0's for numbers -- we really need validation on the values prior to this; you will see how to add validation in <<Validation and Helpers,Validation and Helpers>>.

.AddPhoneBookEntry.cshtml
[source,html]
----
include::source/AddPhoneBookEntry.cshtml[]
----

This is a very basic page; when the insert succeeds, the user is given a brief note, but if there is a problem, the page is replaced with an error page. There is almost no data validation -- all the code does is make sure SQL NULL values will be inserted when the form fields were left blank. It assumes the required field (name) will be present. We will see how to address this in a later chapter with the Validation helper.

[TIP]
====
Notice that we do not insert into the Id column -- because it was defined as an IDENTITY column, unique values will be automatically generated for us. Most SQL engines have this capability, though the syntax is often different.
====

We used the same `Execute` method that the CREATE TABLE and DROP TABLE statements used in our admin page, and could have used the same try..catch around it to determine what went wrong. Execute takes a variable number of parameters, so that you can specify the number to match all of the SQL parameters you have defined in your statement. If you specify fewer values than you have parameters, the Execute statement will throw an SQLException.

The database class has a useful method, `GetLastInsertId`, that you see used in the page.  Because we inserted into a table with an identity column, the database will give us back the value it generated for that column. We give it to the user (though usually you would not, but you might use it for some other, internal purpose).

=== View Data in the Table (SELECT, WebGrid)

Once you have data in your database, you will want to display it to the user. This means getting the data back out of the database. There are three methods on `Database`  that return data:

* `Query` -- for a SELECT statement that you expect to return any number of rows (including zero).
* `QuerySingle` -- for a SELECT statement that you expect to return exactly one row (just a single row)
* `QueryValue` -- for a SELECT statement that you expect to return exactly one column in one row (just a single value).

These methods all have the same parameters as `Execute`: the SELECT statement as a string, followed by any needed parameter values for parameters in the statement.

The Query method returns a collection as an `IEnumerable` -- it is typical to use a foreach loop on the query result, to generate an HTML table. Toward this end, there is a `WebGrid` helper which will transform your IEnumerable not only to a HTML table, but to one with multiple pages.

But let's explore that returned type, first. It is an IEnumerable of ... objects. C# transforms the row in the result to an anonymous object. Anonymous objects are objects created on the fly without an associated class. The row is transformed into an object by making each column value in it a property of the object. The property names are the SELECT column names -- so it's important to name expressions in your SELECT list, or understand how SQL Server names columns that are computed from expressions in SELECTs. If you look at the type of the variable of a row, you see it is `dynamic`. That means that the compiler doesn't know its type, and the runtime will only know it at the moment it gets created.

Let's generate our own table first, and then look at WebGrid.

.SelectTable.cshtml
[source,html]
----
include::source/SelectTable.cshtml[]
----

As you can see, we can dot off of our foreach variable row (which has the type dynamic) with the column names from our table. If you try to dot off of it with a different name, the compiler won't detect the error -- at runtime, you would get an exception.

The row is actually a `WebMatrix.Data.DynamicRecord`, and there are three different ways to access a given column:

. row.ColumnName as used in the code above
. row["ColumnName"]
. row[1] if ColumnName is column number 1 (remember, numbering starts at 0), returns that column

In addition to those access methods, `DyanmicRecord` provides the property `Columns`, which returns a list containing the column names. This can be useful if you do not know the names -- you can use that list to index into the rows with the column names, or to get the count of columns to use the integer indexing.  You can read more about `DynamicRecord` here: https://msdn.microsoft.com/en-us/library/webmatrix.data.dynamicrecord(v=vs.111).aspx.

==== WebGrid Helper

You could use the `DynamicRecord` ability to report column names and index the row columns to write your own helper that would generate an HTML table -- but you don't have to, since ASP.NET has done that. It has developed a very rich helper, `WebGrid`, which not only generates an HTML table, but provides paging so that long data results don't cause long pages.

Here is our example, changed to use WebGrid:

.SelectWebGrid.cshtml
[source,html]
----
include::source/SelectWebGrid.cshtml[]
----

As you can see, we create the `WebGrid` in a Razor code block, and then use its `GetHtml` method to generate the HTML for the Grid later on our page. When we use the `WebGrid` constructor, we supply:

* source: an IEnumerable (in fact, it doesn't even need to come from a query...)
* defaultSort: the column to sort the results on in the table
* rowsPerPage: how many rows to put in the table at a time

The WebGrid will generate an HTML table that lets you click back and forth between "pages" in the table. That switching is all done in the client, so there are no additional trips to the server.

To generate the HTML, call WebGrid's `GetHtml` method. This lets you specify:

* tableStyle: the class to put on the table; in the CSS of our example, you can see how we also applied it to the td's and th's within the table using CSS selectors.
* headerStyle: the class to put on the header row of the table.
* alternatingRowStyle: the class to put on alternating rows; this lets you shade every other row for more visual impact. If not specified, all rows are styled the same.
* columns: identify which columns of the result to display - you can include some or all, and put them in the order you want them to show up in the table.

You can rely on information from the database, and get a basic table, by passing just the SELECT result to WebGrid:
[source,HTML]
----
    var grid = new WebGrid(rows);
----
and then calling GetHtml with no styling options:
[source,HTML]
----
    @grid.GetHtml()
----
This displays all of the data returned in one table, with default table styling.


WebGrid is a very rich helper; as used here, we require all of the data to come back to the client when we define the grid. However, it has the ability to only pull data from the server when it is requested, using AJAX callbacks. To read more about this, see https://msdn.microsoft.com/en-us/library/system.web.helpers.webgrid(v=vs.111).aspx

=== Change Data in the Table (UPDATE and DELETE)

In addition to having data entered, you may wish to allow users to update or delete their data.

Good design is to have the user identify the row they wish to edit or delete, and then to write your code to use the primary key to identify the row in the database. The user should typically not see the keys when they are autogenerated, so you don't display them, but do track them in your code.

When requesting an update, you can either spend effort determining which values were changed by the user, or take the simpler route of assuming they've updated all of the columns. This works fine unless you have a very large column -- then knowing that it was or was not changed is good, since you save alot of space and time by not sending unchanged data back to the server.

A typical model for this is to present the user with a table of all of their data, and then let them choose a row to delete or update. This means that each row in the table has two operations; we could choose to make them links or buttons. Since I've given an multi-butotn example already, I will do this one with links.

.PhoneBookChoices.cshtml
[source,html]
----
include::source/PhoneBookChoices.cshtml[]
----

Notice the "extra" column in the `GetHtml` on the grid:

[source,html]
----
grid.Column("Id","Change",
            format: @<text>
                <a href="~/DeleteEntry.cshtml?id=@item.Id">Delete</a>&nbsp;
                <a href="~/UpdateEntry.cshtml?id=@item.Id">Update</a> </text>)
----

This column uses Id as its underlying value, but has its displayed column header say "Change". We don't want to display the Id, but we do want to use it in links. We do this by generating links directly in the format parameter. Notice that this is embedded HTML, not a string value, for the parameter.

The page link is useful, because it gives us the opportunity to confirm the change with the user; and since we pass in the id, we can fetch the record to display it to them before the confirm their change.

You may have noticed the added link below the table as well, to add a new entry. This links to our AddPhoneBookEntry.cshtml page, which does an insert, but does not link back to our page. ASP.NET gives us a way to make that happen automatically -- once AddPhoneBookEntry.cshtml completes an insert, it doesn't have to stay on its page. If we add this code after db.Close(), we will return to the PhoneBookChoices.cshtml page:

[source,html]
----
Response.Redirect("~/PhoneBookChoices.cshtml");
----


Let's take a look at the delete operation, which also will use a redirect when it completes:

.DeleteEntry.cshtml
[source,html]
----
include::source/DeleteEntry.cshtml[]
----

You can see the redirect after a successful delete -- it returns us to the previous page; the cancel link at the bottom also does this, without making a delete. We keep the id value in the same place by making submit button use id as its name and the id value as its value. Alternatively, we could have made it a hidden field in our form.

This page should be more defensive; it makes these assumptions:

* that the id will find a row
* that a post will find a valid row
* that the delete will remove exactly 1 row, not 0 or more than 1 (since it's a primary key, the 'not more than one' is actually a fine assumption).

So we should expand the page to do these checks and inform the user appropriately if the delete request is no good.

The update operation is similar, but since we have to let the user change the data, we can use `QuerySingle` rather than `Query` to get the single row we are expecting. This time, we will code more defensively as well.

.UpdateEntry.cshtml
[source,html]
----
include::source/UpdateEntry.cshtml[]
----

As you can see, before we display data or make any changes, we validate that we got a row back from `QuerySingle`. If there is no row, we return to the list page (a quiet error) rather than let the user know they phished us, if they were malicious.

This collection of 4 pages: the list of entries, add, delete, and update lets us control the contents of our table. You will see this model again in ASP.NET MVC. These are the 4 basic operations on persistent storage; knowing how to do these 4 lets you then use the operations within other contexts to suit your application's needs.

=== Database class

We've used several methods of the Database class. Here is a list of its property and methods to review:

|====
| Static property |description

| Connection | the current connection
|====

|====
| Static methods | description

| Open(string) |	Opens a connection using the specified connection name or file name.
| OpenConnectionString(string) |	Opens a connection to a database using the specified connection string (these are like the values in our Web.config file).
| OpenConnectionString(String, String) |	Opens a connection to a database using a connection string and a provider.
|====

|====
|Method |description

| Close() |	Closes the database.
| Dispose() |	Releases all resources used by the database.
| Execute(string)	| Executes an SQL statement.
| Execute(string,object,..) | Executes an SQL statement with the specified values for its parameters.
| GetLastInsertId()	| Returns the generated identity column value of the most recently inserted row.
| Query |	Executes a SQL query that returns a list of rows as the result (as an IEnumerable); can specify parameter values
| QuerySingle	| Executes a SQL query that returns a single row as the result (as an anonymous object); can specify parameter values
| QueryValue	| Executes a SQL query that returns a single value as the result (as an object); can specify parameter values
|====

When using this class, it's important to remember to clean up. Otherwise, you may use up more system resources than you need to. So, once you are done with the database, use the Close method to release the connection. If you don't call this explicitly, the resources will be released when the garbage collector realizes no-one is using the database object any longer; but that relies on something that may not occur for a while.

As you saw with the Query, it returns a collection of objects; each object is made up of properties that match the columns in the query. C#'s support for anonymous objects lets this happen automatically. If you define a class to match your query row result, you can convert the SQL result's anonymous class to your class. This lets you treat the rows in your tables like object instances, and your class can define additional behaviours and checks above the database to control how the values are set. You do have to pull them back out to properties to do an INSERT, but you could choose to write behaviors for your objects that handled that for you.

[NOTE]
====
ASP.NET provides an automatic object-to-relational mapping called the Entity Framework and an additional language integrated into C# called LINQ for manipulating databases. Those are beyond the scope of this text, but we will walk through it in ASP.NET Extreme.
====


=== File upload and download

Big files such as images can be stored in databases, but often are not. You can receive a file in an HTTP request and write it out to the server's file system; and take a file from the server's file system and include it in a HTTP response.

TODO

=== Using Maps

TODO

Map http://www.asp.net/web-pages/overview/ui-layouts-and-themes/displaying-maps-in-an-aspnet-web-pages-site



=== Further Reading

* https://msdn.microsoft.com/en-us/library/webmatrix.data.database(v=vs.111).aspx
* http://www.asp.net/web-pages/overview/getting-started/introducing-aspnet-web-pages-2/form-basics
* http://www.asp.net/web-pages/overview/getting-started/introducing-aspnet-web-pages-2/entering-data
* http://www.asp.net/web-pages/overview/data/5-working-with-data
* http://www.mikesdotnetting.com/article/214/how-to-check-if-a-query-returns-data-in-asp-net-web-pages
* http://www.mikesdotnetting.com/article/211/adding-a-footer-to-the-razor-webgrid

=== Exercises

TODO

=== Project

TODO